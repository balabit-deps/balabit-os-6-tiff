Description: fix DoS and possible code execution via large width field in a BMP image
Origin: partly based on https://git.centos.org/blob/rpms!libtiff.git/1ad9335dc0c1325262c62842eda01476243ec821/SOURCES!libtiff-CVE-2015-8668.patch
Bug: http://bugzilla.maptools.org/show_bug.cgi?id=2563

Index: tiff-4.0.6/tools/bmp2tiff.c
===================================================================
--- tiff-4.0.6.orig/tools/bmp2tiff.c	2017-02-24 09:53:59.486686193 -0500
+++ tiff-4.0.6/tools/bmp2tiff.c	2017-02-24 09:56:00.336191475 -0500
@@ -648,18 +648,33 @@
 			    || info_hdr.iCompression == BMPC_RLE4 ) {
 			uint32		i, j, k, runlength;
 			uint32		compr_size, uncompr_size;
+			uint32		bits = 0;
 			unsigned char   *comprbuf;
 			unsigned char   *uncomprbuf;
 
 			compr_size = file_hdr.iSize - file_hdr.iOffBits;
-			uncompr_size = width * length;
-                        /* Detect int overflow */
-                        if( uncompr_size / width != length ) {
-                                TIFFError(infilename,
-                                          "Invalid dimensions of BMP file" );
-                                close(fd);
-                                return -1;
-                        }
+			bits = info_hdr.iBitCount;
+
+			if (bits > 8) // bit depth is > 8bit, adjust size
+			{
+				uncompr_size = width * length * (bits / 8);
+				/* Detect int overflow */
+				if (uncompr_size / width / (bits / 8) != length) {
+					TIFFError(infilename,
+							   "Invalid dimensions of BMP file");
+					close(fd);
+					return -1;
+				}
+			} else {
+				uncompr_size = width * length;
+	                        /* Detect int overflow */
+	                        if( uncompr_size / width != length ) {
+	                                TIFFError(infilename,
+	                                          "Invalid dimensions of BMP file" );
+	                                close(fd);
+	                                return -1;
+	                        }
+			}
                         if ( (compr_size == 0) ||
                              (compr_size > ((uint32) ~0) >> 1) ||
                              (uncompr_size == 0) ||
